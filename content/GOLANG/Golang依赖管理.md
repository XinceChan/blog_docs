```json
{
  "date":"2023.01.17 14:20",
  "author":"XinceChan",
  "tags":["Golang"],
  "musicId":"3986376"
}
```

本章将从工程实践角度，讲授在企业项目实际开发过程中的所遇的难题，重点讲解Go语言的进阶之路，以及在其依赖管理过程中如何演进。包括：1、语言进阶，从并发编程的视角带大家了解Go高性能的本质；2、依赖管理，了解Go语言依赖管理的演进路线；3、测试，从单元测试实践出发，提升大家的质量意识；4、项目实战，通过项目需求、需求拆解、逻辑设计、代码实现带领大家感受下真正的项目开发。

>本节讲述 2、依赖管理，了解Go语言依赖管理的演进路线

## 依赖管理

#### GoPath - 弊端

场景：A和B依赖于某一package的不同版本。

问题：无法实现package的多版本控制

#### GoVender - 弊端

- 无法控制依赖的版本。
- 更新项目又可能出现依赖冲突，导致编译出错。

#### Go Modele

- 通过 `go.mod` 文件管理依赖包版本
- 通过 `go get/go mod` 指令工具管理依赖包

#### 依赖管理三要素

1. 配置文件，描述依赖       `go.mod`
2. 中心仓库管理依赖库       `Proxy`
3. 本地工具               `go get/mod`

#### 依赖管理 - version

**语义化版本**

`${MAJOR}.${MINOR}.${PATH}`

`V1.3.0`  `V2.3.0`

**基于commit伪版本**

`vx.0.0-yyyymmddhhmmss-abcdefgh1234`

`v0.0.0-20220401081311-c38fb59326b7`

`v1.0.0-20201130134442-10cb98267c6c`

#### 依赖配置 - indirect

A -> B -> C

- A -> B: 直接依赖
- A -> C: 间接依赖

#### 依赖配置 - incompatible

- 主版本2+模版会在模块路径增加/vN后缀。
- 对于没有go.mod文件并且主版本2+的依赖，会+incompatible

#### 依赖分发 - 变量GOPROXY

GOPROXY=“https://proxy1.cn, https://proxy2.cn, direct”

服务站点URL列表，“direct”表示源站

